Разработайте структуру данных, которая соответствует ограничениям кэша LRU (наименее давно использованных данных) .

Реализуйте LRUCacheкласс:

LRUCache(int capacity)Инициализируйте кэш LRU положительным размером capacity.
int get(int key)Верните значение, keyесли ключ существует, в противном случае верните -1.
void put(int key, int value)Обновить значение , keyесли keyсуществует. В противном случае добавить key-valueпару в кэш. Если количество ключей превышает capacityиз этой операции, вытеснить наименее недавно использованный ключ.
Функции getи putдолжны выполняться со O(1)средней временной сложностью.

Пример 1:

Вход
["LRUCache", "положить", "положить", "получить", "положить", "получить", "положить", "получить", "получить"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Выход
[ноль, ноль, ноль, 1, ноль, -1, ноль, -1, 3, 4]

Объяснение
LRUCache lRUCache = новый LRUCache(2);
lRUCache.put(1, 1); // кэш {1=1}
lRUCache.put(2, 2); // кэш {1=1, 2=2}
lRUCache.get(1); // вернуть 1
lRUCache.put(3, 3); // Ключ LRU был 2, вытесняет ключ 2, кэш {1=1, 3=3}
lRUCache.get(2); // возвращает -1 (не найдено)
lRUCache.put(4, 4); // Ключ LRU был 1, вытесняет ключ 1, кэш равен {4=4, 3=3}
lRUCache.get(1); // возвращает -1 (не найдено)
lRUCache.get(3); // вернуть 3
lRUCache.get(4); // вернуть 4

Ограничения:

1 <= capacity <= 3000
0 <= key <= 104
0 <= value <= 105
Максимальное количество звонков будет совершаться на номера и .2 \* 105getput
