Учитывая rootдвоичное дерево, преобразуем его в «связанный список»:

«Связанный список» должен использовать тот же TreeNodeкласс, где rightдочерний указатель указывает на следующий узел в списке, а leftдочерний указатель всегда равен null.
«Связанный список» должен быть в том же порядке, что и прямой обход бинарного дерева.
 

Пример 1:


Вход: корень = [1,2,5,3,4,null,6]
 Выход: [1,null,2,null,3,null,4,null,5,null,6]
Пример 2:

Вход: корень = []
 Выход: []
Пример 3:

Вход: корень = [0]
 Выход: [0]
 

Ограничения:

Число узлов в дереве находится в диапазоне [0, 2000].
-100 <= Node.val <= 100
 

Дополнительный вопрос: можно ли выровнять дерево на месте (оставив O(1)дополнительное пространство)?