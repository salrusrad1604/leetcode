Реализуйте BSTIteratorкласс, представляющий итератор для упорядоченного обхода двоичного дерева поиска (BST):

BSTIterator(TreeNode root)Инициализирует объект класса BSTIterator. rootBST задается как часть конструктора. Указатель должен быть инициализирован несуществующим числом, меньшим любого элемента в BST.
boolean hasNext()Возвращает true, если в обходе справа от указателя существует число, в противном случае возвращает false.
int next()Перемещает указатель вправо, затем возвращает число у указателя.
Обратите внимание, что при инициализации указателя несуществующим наименьшим числом первый вызов next()вернет наименьший элемент в BST.

Вы можете предположить, что next()вызовы всегда будут действительными. То есть, будет как минимум следующий номер в упорядоченном обходе, когда next()вызывается.

 

Пример 1:


Вход
["BSTIterator", "следующий", "следующий", "hasNext", "следующий", "hasNext", "следующий", "hasNext"]
[[[7, 3, 15, ноль, ноль, 9, 20]], [], [], [], [], [], [], [], [], []]
Выход
[ноль, 3, 7, правда, 9, правда, 15, правда, 20, ложь]

Объяснение
BSTIterator bSTIterator = новый BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next(); // вернуть 3
bSTIterator.next(); // вернуть 7
bSTIterator.hasNext(); // возвращает True
bSTIterator.next(); // вернуть 9
bSTIterator.hasNext(); // возвращает True
bSTIterator.next(); // вернуть 15
bSTIterator.hasNext(); // возвращает True
bSTIterator.next(); // вернуть 20
bSTIterator.hasNext(); // возвращает Ложь
 

Ограничения:

Число узлов в дереве находится в диапазоне .[1, 105]
0 <= Node.val <= 106
Максимальное количество звонков будет сделано на номера , и .105hasNextnext
 

Следовать за:

Можете ли вы реализовать next()и hasNext()запустить за среднее O(1)время и использовать  O(h)память, где hнаходится высота дерева?