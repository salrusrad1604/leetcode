Имеется целочисленный массив nums, отсортированный по возрастанию (с различными значениями).

Перед передачей в вашу функцию, возможно, вращаетсяnums по неизвестному индексу поворота ( ), так что результирующий массив будет ( индексирован на 0 ). Например, может вращаться по индексу поворота и стать .k1 <= k < nums.length[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]][0,1,2,4,5,6,7]3[4,5,6,7,0,1,2]

Учитывая массив nums после возможного поворота и целое число target, вернуть индекс , targetесли он находится в nums, или -1если он не находится вnums .

Вам необходимо написать алгоритм, обладающий O(log n)сложностью во время выполнения.

Пример 1:

Ввод: числа = [4,5,6,7,0,1,2], цель = 0
Вывод: 4
Пример 2:

Ввод: числа = [4,5,6,7,0,1,2], цель = 3
Вывод: -1
Пример 3:

Ввод: nums = [1], цель = 0
Вывод: -1
