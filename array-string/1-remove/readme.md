Дан целочисленный массив, numsотсортированный в неубывающем порядке , удалить дубликаты на месте так, чтобы каждый уникальный элемент появлялся только один раз . Относительный порядок элементов должен оставаться прежним . Затем вернуть количество уникальных элементов вnums .

Примите во внимание количество уникальных элементов , numsчтобы kбыть принятым, вам необходимо сделать следующее:

Измените массив numsтак, чтобы первые kэлементы numsсодержали уникальные элементы в том порядке, в котором они присутствовали numsизначально. Остальные элементы numsне важны, как и размер nums.
Возвращаться k.
Судья по индивидуальному заказу:

Судья проверит ваше решение с помощью следующего кода:

int[] nums = [...]; // Входной массив
int[] expectedNums = [...]; // Ожидаемый ответ с правильной длиной

int k = removeDuplicates(nums); // Вызывает вашу реализацию

утверждать k == expectedNums.length;
для (int i = 0; i < k; i++) {
    утверждать nums[i] == expectedNums[i];
}
Если все утверждения пройдены, то ваше решение будет принято .

 

Пример 1:

Вход: nums = [1,1,2]
 Выход: 2, nums = [1,2,_]
 Пояснение: Ваша функция должна возвращать k = 2, при этом первые два элемента nums будут 1 и 2 соответственно.
Не имеет значения, что вы оставите после возвращаемого k (поэтому они и есть подчеркивания).
Пример 2:

Вход: nums = [0,0,1,1,1,2,2,3,3,4]
 Выход: 5, nums = [0,1,2,3,4,_,_,_,_,_]
 Пояснение: Ваша функция должна возвращать k = 5, при этом первые пять элементов nums будут 0, 1, 2, 3 и 4 соответственно.
Не имеет значения, что вы оставите после возвращаемого k (поэтому они и есть подчеркивания).
 

Ограничения:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
